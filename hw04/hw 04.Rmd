---
title: "STAT 545 Homework Assignment #4"
output: github_document
---
[Return to Homework 4 Folder](https://github.com/heathersummers/STAT545-hw-Summers-Heather/tree/master/hw04)

[Return to Main Page of Repository](https://github.com/heathersummers/STAT545-hw-Summers-Heather)


##Table of Contents:
[General data reshaping and relationship to aggregation](#general-data-reshaping-and-relationship-to-aggregation)

- [Make your own tidyr cheatsheet](#make-your-own-tidyr-cheatsheet)

- [Make a tibble with one row per year and columns for life expectancy for two or more countries](#make-a-tibble-with-one-row-per-year-and-columns-for-life-expectancy-for-two-or-more-countries)
  
[Join, merge, look up](#join-merge-look-up)

- [Create a second data frame, complementary to gapminder and join this with gapminder](#create-a-second-data-frame-complementary-to-gapminder-and-join-this-with-gapminder)


Load the following packages:
```{r results='hide', message=FALSE, warning=FALSE}
library(gapminder)
library(tidyverse)
library(devtools)
library(knitr)
```


## General data reshaping and relationship to aggregation
### Activity #1
#### Make your own tidyr cheatsheet

<a href="#top">Back to top</a>

The package `tidyr` is used to create tidy data in which each variable is in its own column and each observation is in its own row. Tidy data is particularly good for R (or similar programming languages) since the layout ensures that values of different variables from the same observation are paired (i.e. complements R's vectorized operations). It is best to organise variables by their role in the analysis with fixed variables (i.e. describe the experimental design and are known) first followed by nmeasured variables (i.e. varaibles measured in the study). The two fundamental verbs of data tidying (i.e. structuring datasets to facilitate analysis) are `gather()` and `spread()`.

See below for the format for both `gather()` and `spread()`:

##### function name <- data.frame %>% gather(key, value, ...) 
where key is what you want to call the column headers that became a variable, value is what you want to call the stacked columns that became a variable, and `...` is the items to include (or not include) in the reshape.

Below is a data set used to illustrated the functions `gather()` and `spread()`.

```{r}
data_example <- data.frame(
  name = LETTERS[1:7], 
  test = sample(12:18, 7, TRUE), 
  quiz = sample(1:7, 7, TRUE), 
  assignment = sample(12:18, 7, TRUE)
  )

knitr::kable(data_example)
```

The function `gather()` takes multiple columns and assembles them into key and value columns. The objective of `gather()` is to make wide data (i.e. more columns, less rows) longer.

```{r}
data_example %>%
  gather(distribution, mark, -c(name))
```

On the other hand, the function `spread()` takes the two columns, key and value, and spreads in to multiple columns. The objective of `spread()` is to make long data (i.e. more rows, less columns) wider. Spread rows into columns.

```{r}
data_example %>%
  gather(distribution, mark, -c(name)) %>%
  spread(distribution, mark) #spread the data back out
```

The function `separate` separates one column into several while the function `unite` unites several columns into one.

The package `tidyr` also provides the functions `separate()` and `extract()` which are used to pull apart a column that represents multiple variables. 

#### Related packages
`tidyr` replaces `reshape2` which was used for general reshaping and `reshape` which was used for general aggregation.

| tidyr Functions | reshape2 Functions | database Functions |  spreadsheet Functions |
| :---: | :---: | :---: | :---: |
| gather | melt | fold | unpivot |
|spread | cast | unfold | pivot |


### Activity #2
#### Make a tibble with one row per year and columns for life expectancy for two or more countries

<a href="#top">Back to top</a>

For this activity I will compare the life expectancy of Canada, New Zealand, France, Belgium, and Denmark. First, select data for only those countries using the function `filter()` and then use the function `select()` to retain only the columns for country, year, and life expectancy.

```{r}
data.long <- gapminder %>%
  filter(country %in% c("Canada", "New Zealand", "France", "Belgium", "Denmark")) %>%
  select(country, year, lifeExp)

knitr::kable(data.long, digits = 2, align = "c", col.names = c('Country', 'Year', 'Life Expectancy (Year)'), format = 'markdown')
```

I will now reshape the data using the function `spread()` which will convert a key-value pair across multiple columns making the data wider. `spread()` is particularly helpful for tidying the data in the country column because the five possible values (Canada, New Zealand, France, Belgium, and Denmark) can now be spread into new columns in the reshaped dataframe.

```{r}
data_wide <- data.long %>%
  spread(country, lifeExp)

knitr::kable(data_wide, digits = 2, align = 'c', col.names = c('Year', 'Life Expectancy in Belgium (Year)', 'Life Expectancy in Canada (Year)', 'Life Expectancy in Denmark (Year)', 'Life Expectancy in France (Year)', 'Life Expectancy in New Zealand (Year)'), format = 'markdown')
```

This form is tidy since there is one variable in each column and each row represents one year. For creating the graph I will use the long form (i.e. data_long) of the data since that works best with ggplot.

```{r}
ggplot(data.long,aes(x = year, y = lifeExp, colour = country)) +
  geom_point() +
  geom_line() +
  scale_colour_discrete("Country") +
  scale_x_continuous("Year", breaks = seq(1950, 2010, 10),
                     labels = as.character(seq(1950, 2010, 10)),
                     limits = c(1950, 2010)) +
  scale_y_continuous(breaks = seq(65, 85, 5),
                     labels = as.character(seq(65, 85, 5)),
                     limits = c(65, 85)) +
  theme_bw() +
  theme(axis.title = element_text(size=14, face="bold"),
        plot.title = element_text(size=15, face="bold", hjust=0.48),
        axis.title.x = element_text(size=13),
        axis.title.y = element_text(size=13),
        legend.title = element_text(size=14, face="bold"),
        legend.text = element_text(size=13)) +
  labs(x = "Year", y = "Life Expectancy (Year)", title = "Comparison of Life Expectancies of Several Countries")
```


## Join, merge, look up

<a href="#top">Back to top</a>

Below is a simple cheatsheet I created of the different `join` functions.
Dataset 'a':

| x1 | x2 |
| :---: | :---: |
| A | 3 |
| B | 4 |
| C | 5 |

Dataset 'b':

| x1 | x3 |
| :---: | :---: |
| A | G |
| B | H |
| D | I |

#### Mutating Joins

left_join(a, b, by = "x1")
Join matching rows from 'b' to 'a'.

| x1 | x2 | x3|
| :---: | :---: | :---: |
| A | 3 | G |
| B | 4 | H |
| C | 5 | N/A |

right_join(a, b, by = "x1")
Join matching rows from 'a' to 'b'.

| x1 | x3 | x2 |
| :---: | :---: | :--: |
| A | G | 3 |
| B | H | 4 |
| D | I | N/A |

inner_join(a, b, by = "x1")
Join data, retain only rows in both sets.

| x1 | x2 | x3|
| :---: | :---: | :---: |
| A | 3 | G |
| B | 4 | H |

full_join(a, b, by = "x1")
Join data, retain all values and all rows.

| x1 | x2 | x3|
| :---: | :---: | :---: |
| A | 3 | G |
| B | 4 | H |
| C | 5 | N/A |
| D | N/A | I

#### Filtering Joins
semi_join(a, b, by = "x1")
All rows in 'a' that have a match in 'b'.

| x1 | x2 |
| :---: | :---: |
| A | 3 |
| B | 4 |

anti_join(a, b, by = "x1")
All rows in 'a' that do not have a match in 'b'.

| x1 | x2 |
| :---: | :---: |
| C | 5 |


### Activity #1
#### Create a second data frame, complementary to gapminder and join this with gapminder

<a href="#top">Back to top</a>

For this part of the assignment I downloaded [data](http://appsso.eurostat.ec.europa.eu/nui/submitViewTableAction.do) on air pollutants by source sector from 1990 until 2015 for all countries within the European Union. In particular, I am interested in the air pollutant sulphur oxide and the industrial, agricultural, and waste sector sources. I saved the file as a `.csv` file and imported it into R markdown using the function `read.csv`.

```{r}
data.sox_emis <- read.csv("sox_emis.csv")
attach(data.sox_emis)

glimpse(data.sox_emis)
knitr::kable(head(data.sox_emis, n=10), format = 'markdown')
```

Now, I first want to make this data look more like the gapminder data set.
```{r}
names(data.sox_emis) <- c("year", "country", "air_pollutant", "sect_source", "emission") #rename the columns
knitr::kable(head(data.sox_emis, n=10), format = 'markdown')
```

Now I want to make the total sector source its own column and remove the air pollutant column since it isn't necessary.
```{r}
#Total sector source emissions is its own column and the columns have been renamed
data.sox_emis_2 <- data.sox_emis %>%
  spread(sect_source,emission)
names(data.sox_emis_2) <- c("year", "country", "air-pollutant", "total sector source emissions")
```

```{r}
#Removing the air pollutant column
data.sox_emis_3 <- data.sox_emis_2 %>%
  select(year, country,"total sector source emissions")
knitr::kable(head(data.sox_emis_3, n=10), format = 'markdown', align = 'c', caption = "Sulphur Oxide Air Pollutants in Tonnes for Total Sectors of Emissions")  
```

Now lets join this data frame with the gapminder data frame using various `join` functions.

#### Left Join
The function `left_join` joins matching rows from the gapminder data frame to the air pollutant data frame. The function does this by preserving all the data from gapminder and adding new columns from the air pollutant data to corresponding rows and if there is no match for a row in the air pollutant data frame to the gapminder data frame then the observation is excluded.
```{r}
gapminder.sox.left <- left_join(gapminder, data.sox_emis_3, by = c("country", "year"))
glimpse(gapminder.sox.left)
```

Since the European Union only consists of 28 member states located in Europe we could also filter the gapminder data set to only include countries in Europe.
```{r}
gapminder_europe <- gapminder %>%
  filter(continent == "Europe") #only countries in Europe that way data frame is smaller and more similar to the air pollutant data frame

gapminder_europe.sox.left <- left_join(gapminder_europe, data.sox_emis_3, by = c("country", "year"))
glimpse(gapminder_europe.sox.left)
```

We get this warning message because the `country` columns in both data sets are not just character vectors but are factors. To get rid of the warning message and convert the columns `country` to character vectors used the function `as.character()`.

```{r}
gap_europe <- gapminder_europe
gap_europe$country <- as.character(gap_europe$country)
data.sox_emis_3$country <- as.character(data.sox_emis_3$country)

gapminder_europe.sox.left <- left_join(gap_europe, data.sox_emis_3, by = c("country", "year"))
glimpse(gapminder_europe.sox.left)
```

#### Right Join
The function `right-join` is similar to `left_join` except that the arguments are switched, thus the function joins matching rows from the air pollutant data frame to the gapminder data frame. As such, all the data from air pollutant is retained and data from gapminder have only been added where it matches the rows for country and year in the air pollutant data frame. Thus, there is only continent, life expectancy, population, and GDP per capita data points for the countries within the European Union (i.e. the countries with air pollutant emissions data).
```{r}
gapminder_europe.sox.right <- right_join(gap_europe, data.sox_emis_3, by = c("country", "year"))
glimpse(gapminder_europe.sox.right)
```

#### Inner Join
The function `inner_join` joins the two data frames but only retains rows that are found in both the gapminder and air pollutant data frames resulting in no missing data points. 
```{r}
gapminder_europe.sox.inner <- inner_join(gap_europe, data.sox_emis_3, by = c("country", "year"))
glimpse(gapminder_europe.sox.inner)
```

#### Full Join
The function `full_join` joins the two data frames and retains all the values and rows from both resulting in the largest data frame with lots of missing data points.
```{r}
gapminder_europe.sox.full <- full_join(gap_europe, data.sox_emis_3, by = c("country", "year"))
glimpse(gapminder_europe.sox.full)
```

#### Semi Join
The function `semi_join` is a filtering join in which all the rows in the gapminder data frame are filtered so that only those that have a match in the air pollutant data frame are retained. As such, the sulphur oxide air emissions data points are not included in this data frame and only the gapminder data for countries in the European Union for the years 1992, 1997, 2002, and 2007 are included.
```{r}
gapminder_europe.sox.semi <- semi_join(gap_europe, data.sox_emis_3, by = c("country", "year"))
glimpse(gapminder_europe.sox.semi)
```

#### Anti Join
The function `anti_join` is another filtering join that is the inverse of `semi_join` in which all the rows in the gapminder data frame that do not have a match in the air pollutant data frame are retained. As such, all European countries not part of the European Union have the gapminder data between 1952 until 2007 whereas European countries that are part of the European Union only have gapminder data between 1952 until 1987. In addition, the sulphur oxide air emissions data points for all countries are not included.
```{r}
gapminder_europe.sox.anti <- anti_join(gap_europe, data.sox_emis_3, by = c("country", "year"))
glimpse(gapminder_europe.sox.anti)
```